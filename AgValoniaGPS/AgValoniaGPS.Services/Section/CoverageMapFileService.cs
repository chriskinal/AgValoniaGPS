using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using AgValoniaGPS.Models;
using AgValoniaGPS.Models.Section;

namespace AgValoniaGPS.Services.Section;

/// <summary>
/// Service for reading and writing coverage map files
/// File format: Coverage.txt (text-based triangle data, one triangle per line)
/// Supports chunked loading for large files (100k+ triangles)
/// Thread-safe with file locking to prevent concurrent write corruption
/// </summary>
public class CoverageMapFileService : ICoverageMapFileService
{
    private const string CoverageFileName = "Coverage.txt";
    private const int ChunkSize = 10000; // Process 10k triangles at a time
    private readonly SemaphoreSlim _fileLock = new SemaphoreSlim(1, 1);
    private readonly ICoverageMapService _coverageMapService;

    /// <summary>
    /// Creates a new coverage map file service
    /// </summary>
    /// <param name="coverageMapService">Coverage map service for validation</param>
    public CoverageMapFileService(ICoverageMapService coverageMapService)
    {
        _coverageMapService = coverageMapService ?? throw new ArgumentNullException(nameof(coverageMapService));
    }

    /// <summary>
    /// Saves complete coverage map to Coverage.txt (async)
    /// </summary>
    /// <param name="fieldPath">Path to the field directory</param>
    /// <param name="triangles">Triangles to save</param>
    public async Task SaveCoverageAsync(string fieldPath, IEnumerable<CoverageTriangle> triangles)
    {
        if (string.IsNullOrWhiteSpace(fieldPath))
            throw new ArgumentException("Field path must be specified", nameof(fieldPath));

        if (triangles == null)
            throw new ArgumentNullException(nameof(triangles));

        // Ensure directory exists
        if (!Directory.Exists(fieldPath))
        {
            Directory.CreateDirectory(fieldPath);
        }

        var filePath = Path.Combine(fieldPath, CoverageFileName);

        await _fileLock.WaitAsync();
        try
        {
            await using var fileStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true);
            await using var writer = new StreamWriter(fileStream, Encoding.UTF8);

            // Write header
            await writer.WriteLineAsync("# Coverage Map - Generated by AgValoniaGPS");
            await writer.WriteLineAsync("# Format: SectionId,V1_Lat,V1_Lon,V2_Lat,V2_Lon,V3_Lat,V3_Lon,Timestamp,OverlapCount");

            // Write triangles
            foreach (var triangle in triangles)
            {
                await WriteTriangleAsync(writer, triangle);
            }

            await writer.FlushAsync();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to save coverage to {filePath}", ex);
        }
        finally
        {
            _fileLock.Release();
        }
    }

    /// <summary>
    /// Loads coverage map from Coverage.txt with chunked loading for large files (async)
    /// </summary>
    /// <param name="fieldPath">Path to the field directory</param>
    /// <returns>List of coverage triangles, or empty list if file doesn't exist</returns>
    public async Task<List<CoverageTriangle>> LoadCoverageAsync(string fieldPath)
    {
        if (string.IsNullOrWhiteSpace(fieldPath))
            return new List<CoverageTriangle>();

        var filePath = Path.Combine(fieldPath, CoverageFileName);

        if (!File.Exists(filePath))
            return new List<CoverageTriangle>();

        var triangles = new List<CoverageTriangle>();

        await _fileLock.WaitAsync();
        try
        {
            await using var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);
            using var reader = new StreamReader(fileStream, Encoding.UTF8);

            string? line;
            int lineNumber = 0;
            int validCount = 0;
            int invalidCount = 0;

            while ((line = await reader.ReadLineAsync()) != null)
            {
                lineNumber++;

                // Skip empty lines and comments
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("#"))
                    continue;

                var triangle = ParseTriangleLine(line);
                if (triangle != null)
                {
                    triangles.Add(triangle);
                    validCount++;
                }
                else
                {
                    invalidCount++;
                    if (invalidCount <= 10) // Log first 10 errors only
                        Console.WriteLine($"Warning: Invalid triangle data at line {lineNumber}");
                }
            }

            if (invalidCount > 0)
                Console.WriteLine($"Loaded {validCount} triangles, skipped {invalidCount} invalid lines from {filePath}");

            return triangles;
        }
        catch (Exception ex)
        {
            // Backup corrupted file
            await BackupCorruptedFileAsync(filePath);
            Console.WriteLine($"Error loading coverage from {filePath}: {ex.Message}");
            return new List<CoverageTriangle>();
        }
        finally
        {
            _fileLock.Release();
        }
    }

    /// <summary>
    /// Appends new coverage triangles to existing Coverage.txt file (async)
    /// </summary>
    /// <param name="fieldPath">Path to the field directory</param>
    /// <param name="triangles">Triangles to append</param>
    public async Task AppendCoverageAsync(string fieldPath, IEnumerable<CoverageTriangle> triangles)
    {
        if (string.IsNullOrWhiteSpace(fieldPath))
            throw new ArgumentException("Field path must be specified", nameof(fieldPath));

        if (triangles == null)
            throw new ArgumentNullException(nameof(triangles));

        // Ensure directory exists
        if (!Directory.Exists(fieldPath))
        {
            Directory.CreateDirectory(fieldPath);
        }

        var filePath = Path.Combine(fieldPath, CoverageFileName);

        await _fileLock.WaitAsync();
        try
        {
            // If file doesn't exist, create with header
            if (!File.Exists(filePath))
            {
                await using var createStream = new FileStream(filePath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true);
                await using var createWriter = new StreamWriter(createStream, Encoding.UTF8);
                await createWriter.WriteLineAsync("# Coverage Map - Generated by AgValoniaGPS");
                await createWriter.WriteLineAsync("# Format: SectionId,V1_Lat,V1_Lon,V2_Lat,V2_Lon,V3_Lat,V3_Lon,Timestamp,OverlapCount");
            }

            // Append triangles
            await using var appendStream = new FileStream(filePath, FileMode.Append, FileAccess.Write, FileShare.None, 4096, useAsync: true);
            await using var writer = new StreamWriter(appendStream, Encoding.UTF8);

            foreach (var triangle in triangles)
            {
                await WriteTriangleAsync(writer, triangle);
            }

            await writer.FlushAsync();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Failed to append coverage to {filePath}", ex);
        }
        finally
        {
            _fileLock.Release();
        }
    }

    /// <summary>
    /// Synchronous version of SaveCoverage
    /// </summary>
    public void SaveCoverage(string fieldPath, IEnumerable<CoverageTriangle> triangles)
    {
        SaveCoverageAsync(fieldPath, triangles).GetAwaiter().GetResult();
    }

    /// <summary>
    /// Synchronous version of LoadCoverage
    /// </summary>
    public List<CoverageTriangle> LoadCoverage(string fieldPath)
    {
        return LoadCoverageAsync(fieldPath).GetAwaiter().GetResult();
    }

    /// <summary>
    /// Synchronous version of AppendCoverage
    /// </summary>
    public void AppendCoverage(string fieldPath, IEnumerable<CoverageTriangle> triangles)
    {
        AppendCoverageAsync(fieldPath, triangles).GetAwaiter().GetResult();
    }

    /// <summary>
    /// Writes a single triangle to the stream
    /// Format: SectionId,V1_Lat,V1_Lon,V2_Lat,V2_Lon,V3_Lat,V3_Lon,Timestamp,OverlapCount
    /// </summary>
    private async Task WriteTriangleAsync(StreamWriter writer, CoverageTriangle triangle)
    {
        if (triangle?.Vertices == null || triangle.Vertices.Length != 3)
            return;

        var v1 = triangle.Vertices[0];
        var v2 = triangle.Vertices[1];
        var v3 = triangle.Vertices[2];

        // Use Easting/Northing (UTM coordinates) for consistency
        var line = string.Format(CultureInfo.InvariantCulture,
            "{0},{1:F7},{2:F7},{3:F7},{4:F7},{5:F7},{6:F7},{7:O},{8}",
            triangle.SectionId,
            v1.Easting, v1.Northing,
            v2.Easting, v2.Northing,
            v3.Easting, v3.Northing,
            triangle.Timestamp,
            triangle.OverlapCount);

        await writer.WriteLineAsync(line);
    }

    /// <summary>
    /// Parses a single triangle line
    /// Format: SectionId,V1_Lat,V1_Lon,V2_Lat,V2_Lon,V3_Lat,V3_Lon,Timestamp,OverlapCount
    /// </summary>
    private CoverageTriangle? ParseTriangleLine(string line)
    {
        try
        {
            var parts = line.Split(',');
            if (parts.Length < 9)
                return null;

            // Parse section ID
            if (!int.TryParse(parts[0], NumberStyles.Integer, CultureInfo.InvariantCulture, out int sectionId))
                return null;

            // Parse vertices (Easting/Northing)
            if (!double.TryParse(parts[1], NumberStyles.Float, CultureInfo.InvariantCulture, out double v1Easting) ||
                !double.TryParse(parts[2], NumberStyles.Float, CultureInfo.InvariantCulture, out double v1Northing) ||
                !double.TryParse(parts[3], NumberStyles.Float, CultureInfo.InvariantCulture, out double v2Easting) ||
                !double.TryParse(parts[4], NumberStyles.Float, CultureInfo.InvariantCulture, out double v2Northing) ||
                !double.TryParse(parts[5], NumberStyles.Float, CultureInfo.InvariantCulture, out double v3Easting) ||
                !double.TryParse(parts[6], NumberStyles.Float, CultureInfo.InvariantCulture, out double v3Northing))
                return null;

            // Parse timestamp
            if (!DateTime.TryParse(parts[7], CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out DateTime timestamp))
                timestamp = DateTime.UtcNow;

            // Parse overlap count
            if (!int.TryParse(parts[8], NumberStyles.Integer, CultureInfo.InvariantCulture, out int overlapCount))
                overlapCount = 1;

            // Create triangle
            var v1 = new Position { Easting = v1Easting, Northing = v1Northing };
            var v2 = new Position { Easting = v2Easting, Northing = v2Northing };
            var v3 = new Position { Easting = v3Easting, Northing = v3Northing };

            return new CoverageTriangle(v1, v2, v3, sectionId)
            {
                Timestamp = timestamp,
                OverlapCount = overlapCount
            };
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error parsing triangle line: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// Backs up a corrupted file with timestamp
    /// </summary>
    private async Task BackupCorruptedFileAsync(string filePath)
    {
        try
        {
            if (!File.Exists(filePath))
                return;

            var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var backupPath = $"{filePath}.corrupt_{timestamp}.bak";

            await using var sourceStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read, 4096, useAsync: true);
            await using var destStream = new FileStream(backupPath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, useAsync: true);
            await sourceStream.CopyToAsync(destStream);

            Console.WriteLine($"Backed up corrupted file to: {backupPath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to backup corrupted file: {ex.Message}");
        }
    }
}
